% ====================================
% Zusammenfassung, Fazit und Ausblick
% ====================================

\chapter{Fazit und Ausblick}

Insgesamt lässt sich feststellen, dass die Implementation bei einer größeren Anzahl an Gitterpunkten bei allen vorgestellten Beispielen realitätsnahe Ergebnisse liefert. Bei weniger Gitterpunkten erhalte ich nicht das erwartete Ergebnis, wie z.B. bei Abbildung \ref{fig:riss_ganz_mitte_10_gitter.gebiet} und \ref{fig:riss_ganz_mitte_10_gitter.riss}. Hier reißt das Material am Rand und nicht in der Mitte. Eine mögliche Erklärung ist, dass der Riss sehr groß im Vergleich zu dem Material ist und jegliche Fortsetzung des Risses schon dazu führt, dass das Material auch am Rand gerissen wird. 

\begin{figure}[!bth]
	\centering	\includegraphics[scale=0.40]{images/optimazation/02_2_rissAnEinerSeite_100Gitter_u0Konstant.png}
	\caption{Darstellung des Risses  bei konstantem $u_0$, zwei kleinen Riss an einem Rand und $100x100$ Gitterpunkten}
	\label{fig:2riss_eineSeite_100_gitter.riss}
\end{figure}

Ein anderes, nicht funktionierendes Beispiel, zeigt die Modellierung von zwei Rissen, die in einem Material auf der gleichen Seite sind und aufeinander zu laufen. Ein Riss verschwindet komplett bei vielen Iterationen, wie in Abbildung \ref{fig:2riss_eineSeite_100_gitter.riss} dargestellt. Dies dürfte nicht sein. Wenn das Material einmal gerissen ist, sollte der Riss immer dort bleiben. Weiterführend könnte betrachtet werden, warum dieser Riss verschwindet. Vielleicht ist dies ein Problem in der Modellierung, da in dieser Modellierung die Oberfläche des Risses klein gehalten wird, wenn die Verschiebung des Gebietes nicht zu groß wird. Die Verschiebung des Materials wird klein, wenn schon ein anderer Riss vorhanden ist. Dadurch könnte der Riss verschwinden. 

Betrachten wir die Laufzeit der Implementation. Diese liegt bei $O(n^2)$, wobei $n$ die Breite bzw. Höhe des Gitters ist. Dieses ist in \ref{fig:laufzeit} zu sehen. Eigentlich sollte es in $O(n)$ möglich sein, das Problem zu implementieren, da nur Matrizen aufgestellt werden und mehrere Matrixmultiplikationen mit Sparse-Matrizen stattfinden, die sehr effizient sind. Beim genaueren Betrachten des Codes fällt auf, dass meine Implementation sehr viel Zeit bei dem erstellen der Matrizen braucht. Dieses könnte vermutlich sehr viel effizienter berechnet werden. 

 \begin{figure}[!htb]
 	\centering	\includegraphics[scale=0.42]{images/laufzeit.png}
 	\caption{Laufzeit der Implemention. Auf der x-Achse ist die Gitterweite, auf der y-Achse die Zeit in Sekunden angegeben}
 	\label{fig:laufzeit}
 \end{figure}

In der analytischen Betrachtung könnte man untersuchen, ob weniger Voraussetzungen an $u_0$ und $v_0$ gestellt werden müssen. Stetigkeit von $u_0$ sollte ausreichend sein, ist aber auch notwendig. In der Praxis kann man Material nicht unstetig einspannen.  

Eine wichtige Untersuchung wäre die Konvergenz der Newton Methode. Diese zu beweisen erweist sich als sehr schwierig, da nicht klar ist, ob die Regularitätsannahme erfüllt ist. Im Diskreten konvergiert die Methode für alle untersuchten Beispiele, was natürlich keine Aussage darüber trifft, ob sie auch im analytischen Sinn konvergiert. 

